#### 概念
工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由
于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必
会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂
来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。

#### 角色
在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂
方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有
时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，
它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解
抽象工厂模式，我们先引入两个概念：
- 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔
  电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等
  级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
- 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中
  的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品
  等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个
  产品族。

产品等级结构与产品族示意图如图3所示：
![image](https://github.com/shenjy24/documents/raw/master/images/abstract-factory-1.png)

当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结
构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂
模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，
工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一
个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构
可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方
法模式更为简单、更有效率。

抽象工厂模式示意图如图4所示：
![image](https://github.com/shenjy24/documents/raw/master/images/abstract-factory-02.png)

每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方
形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，
图4所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减
少了系统中类的个数。

#### 结构
抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中
的具体工厂不只是创建一种产品，它负责创建一族产品。抽象工厂模式定义如下：
抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而
无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。
在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，
这些产品构成了一个产品族，抽象工厂模式结构如图5所示：

![image](https://github.com/shenjy24/documents/raw/master/images/abstract-factory.png)

在抽象工厂模式结构图中包含如下几个角色：
- AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
- ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
- AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
- ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：
```
abstract class AbstractFactory {
    public abstract AbstractProductA createProductA(); //工厂方法一
    public abstract AbstractProductB createProductB(); //工厂方法二  
    ……
}
```
具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：
```
class ConcreteFactory1 extends AbstractFactory {
    //工厂方法一
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }
    //工厂方法二
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
    ……
}
```

#### 实例
![image](https://github.com/shenjy24/documents/raw/master/images/abstract-factory-demo.png)

解决方案：
![image](https://github.com/shenjy24/documents/raw/master/images/abstract-factory-solution.png)
